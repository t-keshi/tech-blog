---
title: Draft
date: '2015-05-01T22:12:03.284Z'
description: 'zennの下書き'
---

# あるフロントエンドの悩み

言い伝えによると、テストを書いていないと夜な夜なサバンナライオンが現れて、
「テスト書いてないとか、お前それ@t_wadaの前でも同じこと言えんの？」と枕元で囁き続けるらしい。

でも、テストを書くのは大変なんだ。

第一に、「色々なツールがあって何を選んだらいいか、わからない」
第二に、「フロントエンドのテストは壊れやすくて、管理するのが大変」
第三に、「何をどうテストしていいのか、わからない」

夜も眠れぬ悩み...。

テストアイスクリームコーン。

アイスクリームコーンは、QAの労力と労力の大部分を手動のテスト定義と実行に費やす、ショップから生まれたものです。
時間の経過とともに、ソフトウェアでサポートされる機能セットが増えるにつれて、必要なテスト作業の量は、

製品は、長いリードタイム、低品質、および予測できない結果について悲鳴を上げます。エンジニアリングは、QAが欠陥をキャッチしていないことについて悲鳴を上げます。QAは、仕事をうまく遂行するのに十分なリソースがないことについて悲鳴を上げます。私たちは皆、確かにアイスクリームについて悲鳴を上げます。

また、タイヤをどんなに入念にチェックしようと脱輪する可能性があるのと同じで、単体テストが単独でうまく機能する場合でも、それらが組み合わさったときにうまく機能するかどうかはわかりません。
実際、アプリケーションに含まれるバグの多くは、タイヤではなくて、タイヤと車体の繋ぎ目の部分で起きています。


# 色々なツールがあって何を選んだらいいか、わからない

結論から書くと、Reactの場合、

- Jest
- react-testing-library

の組み合わせ一択だと思います。

## テストランナー/テストフレームワーク/アサーションライブライリ

他にもテストランナーには、Karma
テストフレームワークには、Jasmine, Mocha,
アサーションライブライリには、Chai
と色々あるみたいでややこしいのですが、基本的なことはJestでできますし、Jestはとても小さく始められます。
特にcreate-react-appを使ってReactアプリをスタートする場合、Jestのテスト環境を予め自動で作ってくれるので、すぐテストを始められます。
そして何より、Jestは[React公式ドキュメント](https://reactjs.org/docs/testing.html)で推奨されています。
他のテストランナーやアサーションライブライリに手を出すのは、Jestに慣れてきてからで良いと思います。
それでも十分比較検討してから始めたいという方は、[Jest vs Mocha vs Jasmine](https://www.lambdatest.com/blog/jest-vs-mocha-vs-jasmine/)をご確認ください。

## DOMテスティングライブラリ

ただJestだけだと、Reactのコンポーネントを十分にテストすることができないので、
以下のどちらかのDOMテスティングライブラリ必要になってきます

- Enzyme / React testing library

これについてはReact testing libraryの方を強く推します。
[React公式ドキュメント]でも以前は、Enzymeが推奨されていましたが、現在は[React testing libraryに変わって](https://github.com/reactjs/reactjs.org/pull/3660 )います。
[このコミット](https://github.com/reactjs/reactjs.org/commit/601c016f49719819dd74799f0b334e50311c8d88)を見るとDan先生もReact testing libraryの方を推されているようです。

他にもEnzymeの特徴であるShallowRenderingは、

> With shallow rendering, I can refactor my component's implementation and my tests break.コンポーネントの実装をリファクタリングするとテストが壊れる
ことがあり、また、
> テストをちゃんと通っている状態をキープしたまま、アプリケーションを壊すことができる

という問題を孕んでいます。
これについて詳しくは、[Why I Never Use Shallow Rendering](https://kentcdodds.com/blog/why-i-never-use-shallow-rendering)をご覧ください。

あと、`cypress`というE2Eテストのライブラリもあり、ブラウザの自動テストができます。
これは非常に素晴らしいライブラリで、公式ドキュメントも整備されていて読みやすいです。ブラウザで動くのでレイアウトが崩れていないかなどUI部分もチェックできるのも利点です。
ただメンテナンスコストが高く、ブラウザでテストしない結合テストと比べると、実行速度は遅いです。
(導入を試みましたが、Windowsを使っている人はうまく動かなかったりと...色々大変でした)
以上のような理由で、ここではCypressは取り上げないことにします。

Cypressについては下記をご覧ください。
Cypressの良さみも辛みもわかってくると思います。
[Cypress をお供にE2E受け入れテスト駆動開発 〜そしてAutifyへ〜](https://note.com/seyanote/n/n68825bf83138)
[ReactコンポーネントのテストにCypress Component Test Runnerが良さそうという話](https://tech.prog-8.com/entry/2021/05/14/161041)

# フロントエンドのテストは壊れやすくて、管理するのが大変

ひとつ目のテストの道具をどれを選んだいいかわからない問題は解決しました。
これでぐっすり寝られるでしょうか？、いいえ、まだフロントエンドのテストは壊れやすくて、管理するのが大変という問題があります。
誰だって壊れやすいテストの子守りをするために多くの時間を費やしたくはありません。

これについては、
「壊れにくい上手いテストの書き方と、壊れやすい下手なテストの書き方がある」
ということに尽きます。

壊れやすい下手なテストとは、[実装の詳細テスト](Testing Implementation Details)で,
「ユーザーが普通は目にしたり、知ることのないことをテストすること」です。
モーダルの開閉で例えると、ユーザーが見るのは新規保存ボタンを押したらモーダルが開くということであり、
キャンセルまたは保存ボタンを押したらそのモーダルが閉じるということです。
逆にユーザーが知らないのは、モーダルにisOpenというbooleanの値がpropsとして渡されているということであり、
onCloseが発火するとisOpenの値がfalseになるということです。

より具体的には、Reactのケースだと、

- ライフサイクルメソッド
- イベントハンドラー
- 内部コンポーネントの状態

がテストコードに現れるときには実装の詳細をテストしていることを知らせる危険な兆候です。

(余談ですが、こういう例ってなぜかいつもFizzBuzzかカウンターアプリなのですが、実務でFizzBuzzやカウンターアプリを実際に作ることってほとんどないと思うので、イメージわきにくいかな〜と思います)

# 何をどれくらい、どのようにテストすれば良いのか

「何をどれくらい、どのようにテストすれば良いのか」というのも怖ろしく難しいテーマです。
テストの分類とそのバランスについて、[On the Diverse And Fantastical Shapes of Testing](https://martinfowler.com/articles/2021-test-shapes.html)にもあるように、色々な意見があります。
Googleの[テストブログ](https://testing.googleblog.com/2010/12/test-sizes.html)を読むと、テストに関する用語が氾濫した現状があるため、敢えて「小」「中」「大」という限りなく単純な分類を採用しています。
[shopifyのサイト](https://engineering.atspotify.com/2018/01/11/testing-of-microservices/)では、従来のピラミッド型のテスト戦略の問題とともに、ハニカム型のテストの分類が紹介されています。

1.トロフィー型

E2Eテスト/結合テスト/単体テスト/静的テストに分類し、結合テストに重きを置く。

2.ハニカム型

総合テスト/結合テスト/実装の詳細テストに分類し、結合テストに重きを置く。

3.ピラミッド型

UIテスト/実用テスト/単体テスト

非常に難しそうです。
数多くの用語があり、議論が錯綜しています。

この問題に対する指標になりそうな言葉が以下になります。
> ある人が壁を塗っているとします。彼は偶然にも、ローラーでその壁のほとんど塗ることができました。しかし、ブラシを持って脚立を登るまでは壁の端は塗ることができないのです。

つまり、言いたいのはこうです。
最終的に大事なのは、アプリケーションに対して自信を持ってリリースすることであり、夜中の3時に飛び起きて緊急のバグ対応をするはめにならないという結果(ここでは壁を塗ること)です。
単体テスト(ブラシ)、結合テスト(左官)、E2Eテスト(ローラー)などあって、これらの道具を使ってバグ(塗り残し)がないようにします。
最終的に上手く塗りけれれば何を用いたかはそんなに重要ではありません。

まとめると、
> どのテストのタイプを書くどんな割合で書くか議論するのが流行っていますが、それは混乱を招くものです。明確な境界によって分けれた意味のあるテストで、スピーディーかつ安定的にテストが走り、妥当な理由があるときだけに失敗するテストを書いているチームはほとんど存在しません。分類にこだわる代わりに、「スピーディーかつ安定的にテストが走り、妥当な理由があるときだけに失敗する」ことにこだわるべきです。
ということになります。

# 実際にテストを書いてみる

あるフロントエンドの悩みにあげた３つはここまでで解決したこととします。
誤解のようなにちょっと補足しておくと、テストに関する定義や分類が重要でないといっているわけではなく、それらは実際有益なことだと思っています。ただ、まずスタート地点としてはテストを書いてみることです。

## テストの始め方

とはいえ、テストを始める前に、ESLintやTypeScriptは入れておくべきだと思います。
[GitHub Actionsにreviewdogを飼ってみた！(eslint編)](https://dev.classmethod.jp/articles/shuntaka-github-actions-reviewdog/)にあるように、reviewdogを飼うのも良い方法です。
また、[TypeScriptを使っていたらAirBnbの38%のバグは未然に防げた](https://www.reddit.com/r/typescript/comments/aofcik/38_of_bugs_at_airbnb_could_have_been_prevented_by/)そうです。

## テストを書く(例: ログインフォームのテスト)

# まとめ

最後までお読みいただきありがとうございました！

"People love debating what percentage of which type of tests to write, but it's a distraction. Nearly zero teams write expressive tests that establish clear boundaries, run quickly & reliably, and only fail for useful reasons. Focus on that instead."[^1]: 脚注の内容その1
[Justin Searls](https://twitter.com/searls/status/1393385209089990659?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1393385209089990659%7Ctwgr%5E%7Ctwcon%5Es1_&ref_url=https%3A%2F%2Fmartinfowler.com%2Farticles%2F2021-test-shapes.html)

## 補足

テストの分類、バランスについては以下が参考になります。
[Static vs Unit vs Integration vs E2E Testing for Frontend Apps](https://kentcdodds.com/blog/static-vs-unit-vs-integration-vs-e2e-tests)
それぞれのテストの種類には、長所と短所があるので、取捨選択してください。
単純化すると、以下のようなイメージです。

- 単体テスト: タイヤをチェックします
- 結合テスト: 車が走ることをチェックします
- E2Eテスト: ユーザーは、車に乗車し、公道を一周して戻ってきます
